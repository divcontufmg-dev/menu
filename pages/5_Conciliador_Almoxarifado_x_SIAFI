
import streamlit as st
import pandas as pd
import pdfplumber
import re
from fpdf import FPDF, XPos, YPos
import io
import os
import pytesseract
from pdf2image import convert_from_bytes
from PIL import Image
from pytesseract import Output

# ==========================================
# CONFIGURA√á√ÉO INICIAL
# ==========================================
st.set_page_config(
    page_title="Conciliador: Conta Corrente x Conta Cont√°bil",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="collapsed"
)

hide_streamlit_style = """
            <style>
            #MainMenu {visibility: hidden;}
            footer {visibility: hidden;}
            header {visibility: hidden;}
            </style>
            """
st.markdown(hide_streamlit_style, unsafe_allow_html=True)

# ==========================================
# FUN√á√ïES E CLASSES
# ==========================================

def limpar_valor(v):
    if v is None or pd.isna(v): return 0.0
    if isinstance(v, (int, float)): return float(v)
    v = str(v).replace('"', '').replace("'", "").strip()
    if re.search(r',\d{1,2}$', v): v = v.replace('.', '').replace(',', '.')
    elif re.search(r'\.\d{1,2}$', v): v = v.replace(',', '')
    try: return float(re.sub(r'[^\d.-]', '', v))
    except: return 0.0

def formatar_real(valor):
    return f"{valor:,.2f}".replace(',', '_').replace('.', ',').replace('_', '.')

class PDF_Report(FPDF):
    def header(self):
        self.set_font('helvetica', 'B', 12)
        self.cell(0, 10, 'Relat√≥rio de Confer√™ncia: Conta Corrente x Conta Cont√°bil', align='C', new_x=XPos.LMARGIN, new_y=YPos.NEXT)
        self.ln(5)
    def footer(self):
        self.set_y(-15); self.set_font('helvetica', 'I', 8)
        self.cell(0, 10, f'P√°gina {self.page_no()}', align='C')

# ==========================================
# INTERFACE
# ==========================================
st.title("üìä Conciliador por Abas: Conta Corrente x Conta Cont√°bil")
st.markdown("---")

st.subheader("üìÇ √Årea de Arquivos")
st.write("Fa√ßa o upload de **UMA planilha Excel (com v√°rias abas)** e dos **arquivos PDF correspondentes**.")
uploaded_files = st.file_uploader(
    "Arraste a Planilha √önica e os PDFs para esta √°rea:", 
    accept_multiple_files=True
)

if st.button("‚ñ∂Ô∏è Iniciar Auditoria", use_container_width=True, type="primary"):
    
    if not uploaded_files:
        st.warning("‚ö†Ô∏è Por favor, adicione os arquivos antes de processar.")
    else:
        progresso = st.progress(0)
        status_text = st.empty()
        
        # Separa os PDFs e pega o primeiro arquivo Excel encontrado
        pdfs = {f.name: f for f in uploaded_files if f.name.lower().endswith('.pdf')}
        excel_files = [f for f in uploaded_files if f.name.lower().endswith(('.xlsx', '.xls'))]
        
        pares = []
        logs = []

        if not excel_files:
            st.error("‚ùå Nenhuma planilha Excel (.xlsx ou .xls) foi encontrada no upload.")
        else:
            planilha_mestre = excel_files[0] # Pega a primeira planilha enviada
            
            try:
                # Carrega o arquivo Excel para ler o nome das abas
                planilha_mestre.seek(0)
                xls = pd.ExcelFile(planilha_mestre)
                nome_abas = xls.sheet_names
                
                # Para cada aba, tenta encontrar o c√≥digo da UG e casar com um PDF
                for aba in nome_abas:
                    # Procura uma sequ√™ncia de n√∫meros no nome da aba (ex: "153287", "UG_153287", etc)
                    match = re.search(r'(\d+)', aba)
                    if match:
                        ug = match.group(1)
                        # Procura um PDF que comece com esse c√≥digo
                        pdf_match = next((f for n, f in pdfs.items() if n.startswith(ug)), None)
                        
                        if pdf_match:
                            pares.append({
                                'ug': ug, 
                                'nome_aba': aba, 
                                'pdf': pdf_match
                            })
                        else:
                            logs.append(f"‚ö†Ô∏è Aba '{aba}' (UG {ug}): Planilha encontrada, mas falta o PDF correspondente.")
                    else:
                        logs.append(f"‚ÑπÔ∏è Aba '{aba}' ignorada: N√£o foi encontrado um n√∫mero de UG no nome da aba.")
                        
            except Exception as e:
                st.error(f"‚ùå Erro ao ler a estrutura da planilha Excel: {e}")
        
        if not pares:
            st.error("‚ùå Nenhum par completo (Aba do Excel + PDF) foi identificado.")
        else:
            pdf_out = PDF_Report()
            pdf_out.add_page()
            
            st.markdown("---")
            st.subheader("üîç Resultados da An√°lise")

            for idx, par in enumerate(pares):
                ug = par['ug']
                nome_aba = par['nome_aba']
                status_text.text(f"Processando Aba '{nome_aba}' (UG: {ug})...")
                
                with st.container():
                    st.info(f"üè¢ **Unidade Gestora: {ug} (Aba: {nome_aba})**")
                    
                    # === 1. LEITURA EXCEL (POR ABA) ===
                    df_padrao = pd.DataFrame()
                    
                    try:
                        # L√™ especificamente a aba atual
                        planilha_mestre.seek(0)
                        df_raw = pd.read_excel(planilha_mestre, sheet_name=nome_aba, header=None)
                        
                        # Procurar a linha que cont√©m "Conta Corrente" para usar como cabe√ßalho
                        idx_cabecalho = df_raw[df_raw.apply(lambda r: r.astype(str).str.contains('Conta Corrente', case=False).any(), axis=1)].index
                        
                        if not idx_cabecalho.empty:
                            df_raw.columns = df_raw.iloc[idx_cabecalho[0]]
                            df = df_raw.iloc[idx_cabecalho[0]+1:].reset_index(drop=True)
                            
                            # Coluna A (√çndice 0) = Conta Corrente
                            df['Conta_Corrente'] = df.iloc[:, 0].astype(str).str.replace(r'\.0$', '', regex=True).str.strip().str.zfill(2)
                            
                            # Coluna E (√çndice 4) = Saldo
                            df['Valor_Limpo'] = df.iloc[:, 4].apply(limpar_valor)
                            
                            # Descri√ß√£o Gen√©rica
                            df['Descricao_Excel'] = "Conta Corrente " + df['Conta_Corrente']
                            
                            # Filtra lixos e nulos
                            df = df[df['Conta_Corrente'] != 'NAN']
                            df = df[df['Conta_Corrente'].str.isnumeric()]
                            
                            df_padrao = df.groupby('Conta_Corrente').agg({
                                'Valor_Limpo': 'sum',
                                'Descricao_Excel': 'first'
                            }).reset_index()
                            df_padrao.columns = ['Chave_Vinculo', 'Saldo_Excel', 'Descricao_Completa']
                        else:
                            logs.append(f"‚ö†Ô∏è Aba '{nome_aba}' (UG {ug}): Cabe√ßalho 'Conta Corrente' n√£o encontrado.")
                    except Exception as e:
                        logs.append(f"‚ùå Erro na leitura da Aba '{nome_aba}' (UG {ug}): {e}")

                    # === 2. LEITURA PDF ===
                    df_pdf_final = pd.DataFrame()
                    dados_pdf = []
                    
                    try:
                        par['pdf'].seek(0)
                        pdf_bytes = par['pdf'].read()
                        
                        with pdfplumber.open(io.BytesIO(pdf_bytes)) as p_doc:
                            for page in p_doc.pages:
                                txt = page.extract_text()
                                is_ocr = False
                                
                                tem_dados_validos = False
                                if txt and re.search(r'\d{1,3}(?:[.,]\d{3})*[.,]\d{2}', txt):
                                    tem_dados_validos = True
                                
                                if not txt or not tem_dados_validos or len(txt) < 50:
                                    is_ocr = True
                                    try:
                                        imagens = convert_from_bytes(pdf_bytes, first_page=page.page_number, last_page=page.page_number, dpi=300)
                                        if imagens:
                                            img = imagens[0]
                                            try:
                                                osd = pytesseract.image_to_osd(img, output_type=Output.DICT)
                                                if osd['rotate'] != 0:
                                                    img = img.rotate(-osd['rotate'], expand=True)
                                            except: pass
                                            txt = pytesseract.image_to_string(img, lang='por', config='--psm 6')
                                    except Exception: pass

                                if not txt: continue

                                for line in txt.split('\n'):
                                    if re.match(r'^"?\d+"?\s*[-]?\s*[A-Za-z]', line) or re.match(r'^"?\d+', line):
                                        vals = []
                                        if is_ocr:
                                            vals_raw = re.findall(r'([\d\.\s]+,\d{2})', line)
                                            vals = [v.replace(' ', '') for v in vals_raw]
                                        else:
                                            vals = re.findall(r'([0-9]{1,3}(?:[.,][0-9]{3})*[.,]\d{2})', line)
                                        
                                        if len(vals) >= 1:
                                            chave_match = re.match(r'^"?(\d+)', line)
                                            if chave_match:
                                                conta_contabil_completa = chave_match.group(1)
                                                chave_vinculo = str(conta_contabil_completa[-2:]).zfill(2)
                                                saldo_atual_pdf = limpar_valor(vals[-1])
                                                
                                                dados_pdf.append({
                                                    'Chave_Vinculo': chave_vinculo,
                                                    'Saldo_PDF': saldo_atual_pdf
                                                })
                        
                        if dados_pdf:
                            df_pdf_final = pd.DataFrame(dados_pdf).groupby('Chave_Vinculo')['Saldo_PDF'].sum().reset_index()
                    except Exception as e:
                        logs.append(f"‚ùå Erro Leitura PDF UG {ug}: {e}")

                    # === 3. CRUZAMENTO E COMPARA√á√ÉO ===
                    if df_padrao.empty: df_padrao = pd.DataFrame(columns=['Chave_Vinculo', 'Saldo_Excel', 'Descricao_Completa'])
                    if df_pdf_final.empty: df_pdf_final = pd.DataFrame(columns=['Chave_Vinculo', 'Saldo_PDF'])

                    df_padrao['Chave_Vinculo'] = df_padrao['Chave_Vinculo'].astype(str)
                    df_pdf_final['Chave_Vinculo'] = df_pdf_final['Chave_Vinculo'].astype(str)

                    final = pd.merge(df_pdf_final, df_padrao, on='Chave_Vinculo', how='outer').fillna(0)
                    final['Descricao'] = final.apply(lambda x: x['Descricao_Completa'] if x['Descricao_Completa'] != 0 else f"Conta {x['Chave_Vinculo']} (Sem no Excel)", axis=1)
                    
                    final['Diferenca'] = (final['Saldo_PDF'] - final['Saldo_Excel']).round(2)
                    divergencias = final[abs(final['Diferenca']) > 0.05].copy()

                    # === EXIBI√á√ÉO ===
                    soma_pdf = final['Saldo_PDF'].sum()
                    soma_excel = final['Saldo_Excel'].sum()
                    dif_total = soma_pdf - soma_excel

                    col1, col2, col3 = st.columns(3)
                    col1.metric("Total Saldo Atual (PDF)", f"R$ {soma_pdf:,.2f}")
                    col2.metric("Total Saldo (Excel)", f"R$ {soma_excel:,.2f}")
                    col3.metric("Diferen√ßa Total", f"R$ {dif_total:,.2f}", delta_color="inverse" if abs(dif_total) > 0.05 else "normal")
                    
                    if not divergencias.empty:
                        st.warning(f"‚ö†Ô∏è Aten√ß√£o: {len(divergencias)} conta(s) com diverg√™ncia.")
                        with st.expander("Ver Detalhes das Diverg√™ncias"):
                            st.dataframe(divergencias[['Chave_Vinculo', 'Descricao', 'Saldo_PDF', 'Saldo_Excel', 'Diferenca']])
                    else:
                        st.success("‚úÖ Tudo certo! Nenhuma diverg√™ncia encontrada entre as contas do PDF e Excel.")

                    st.markdown("---")

                    # === GERA√á√ÉO PDF FINAL ===
                    pdf_out.set_font("helvetica", 'B', 11)
                    pdf_out.set_fill_color(240, 240, 240)
                    pdf_out.cell(0, 10, text=f"Unidade Gestora: {ug} (Aba: {nome_aba})", border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, fill=True)
                    
                    if not divergencias.empty:
                        pdf_out.set_font("helvetica", 'B', 9)
                        pdf_out.set_fill_color(255, 200, 200)
                        pdf_out.cell(15, 8, "Chave", 1, fill=True)
                        pdf_out.cell(85, 8, "Descri√ß√£o (Conta Corrente)", 1, fill=True)
                        pdf_out.cell(30, 8, "SALDO PDF", 1, fill=True)
                        pdf_out.cell(30, 8, "SALDO EXCEL", 1, fill=True)
                        pdf_out.cell(30, 8, "Diferen√ßa", 1, fill=True, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
                        
                        pdf_out.set_font("helvetica", '', 8)
                        for _, row in divergencias.iterrows():
                            pdf_out.cell(15, 7, str(row['Chave_Vinculo']), 1)
                            pdf_out.cell(85, 7, str(row['Descricao'])[:48], 1)
                            pdf_out.cell(30, 7, formatar_real(row['Saldo_PDF']), 1)
                            pdf_out.cell(30, 7, formatar_real(row['Saldo_Excel']), 1)
                            pdf_out.set_text_color(200, 0, 0)
                            pdf_out.cell(30, 7, formatar_real(row['Diferenca']), 1, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
                            pdf_out.set_text_color(0, 0, 0)
                    else:
                        pdf_out.set_font("helvetica", 'I', 9)
                        pdf_out.cell(0, 8, "Nenhuma diverg√™ncia encontrada nas contas.", 1, new_x=XPos.LMARGIN, new_y=YPos.NEXT)

                    pdf_out.ln(2)
                    pdf_out.set_font("helvetica", 'B', 9)
                    pdf_out.set_fill_color(220, 230, 241)
                    pdf_out.cell(100, 8, "TOTAIS", 1, fill=True)
                    pdf_out.cell(30, 8, formatar_real(soma_pdf), 1, fill=True)
                    pdf_out.cell(30, 8, formatar_real(soma_excel), 1, fill=True)
                    if abs(dif_total) > 0.05: pdf_out.set_text_color(200, 0, 0)
                    pdf_out.cell(30, 8, formatar_real(dif_total), 1, fill=True, new_x=XPos.LMARGIN, new_y=YPos.NEXT)
                    pdf_out.set_text_color(0, 0, 0)
                    pdf_out.ln(5)
                
                progresso.progress((idx + 1) / len(pares))

            status_text.text("Processamento conclu√≠do!")
            progresso.empty()
            
            if logs:
                with st.expander("‚ö†Ô∏è Avisos do Sistema (Arquivos e Abas Ignorados)"):
                    for log in logs: st.write(log)
            
            try:
                pdf_bytes = bytes(pdf_out.output())
                st.download_button("BAIXAR RELAT√ìRIO DE CONCILIA√á√ÉO PDF", pdf_bytes, "RELATORIO_CONTA_CORRENTE_ABAS.pdf", "application/pdf", type="primary", use_container_width=True)
            except Exception as e:
                st.error(f"Erro ao gerar o download: {e}")
